# encoding: utf-8
require "logstash/filters/base"
require "logstash/namespace"

require 'aws-sdk-v1'



class LogStash::Filters::S3UploadMalwareResults < LogStash::Filters::Base

  include Aerospike

  config_name "s3-upload-malware-results"

  # Where results are going to be stored in s3.
  config :s3_path,                          :validate => :string,           :default => "/mdata/resultData/realTime/"
  # File from which is going to be taken the name.
  config :file_field,                       :validate => :string,           :default => "[path]"
  # Hash field.
  config :hash_field,                       :validate => :string,           :default => 'hash'
  # Results that are going to be upload to s3.
  config :results_field,                    :validate => :string,           :required => true
  # Loader name.
  config :loader,                           :validate => :string,           :required => true
  # S3 bucket
  config :bucket,                           :validate => :string,           :default => "malware"
  # S3 Endpoint
  config :endpoint,                         :validate => :string,           :default => "s3.redborder.cluster"
  # S3 Access key
  config :access_key_id,                    :validate => :string,           :required => true
  # S3 Secret Access key
  config :secret_access_key,                :validate => :string,           :required => true
  # S3 force_path_style option
  config :force_path_style,                 :validate => :boolean,          :default => true
  # S3 ssl_verify_peer option
  config :ssl_verify_peer,                  :validate => :boolean,          :default => false
  # Certificate path
  config :ssl_ca_bundle,                    :validate => :string,           :default => "/var/opt/opscode/nginx/ca/s3.redborder.cluster.crt"


  public
  def register
    # Add instance variables
    @s3 = AWS::S3::Client.new(
      endpoint: @endpoint,
      access_key_id: @access_key_id,
      secret_access_key: @secret_access_key,
      force_path_style:  @force_path_style,
      ssl_verify_peer: @ssl_verify_peer,
      ssl_ca_bundle: @ssl_ca_bundle
    )
  end # def register

  private

  def upload_results_file_to_s3

    time = Time.at(@timestamp.to_i)

    year  = time.year.to_s
    month = ('%02d' % time.month).to_s
    day   = ('%02d' % time.day).to_s
    hour  = ('%02d' % time.hour).to_s

    folder = year + "/" + month + "/" + day  + "/" + hour  + "/" + @uuid

    s3_result_path = @s3_path + folder

    temporary_file_path = '/tmp/' + @uuid

    results = []
    begin
      results.push(eval(@s3.get_object(bucket_name: @bucket, key: s3_result_path).data[:data]))

    rescue AWS::S3::Errors::NoSuchKey
      results = []
      @analysis["sha256"] = "#{@hash}"
    rescue => e
      @logger.error(e.message)
    end

    @analysis["loader"] = @loader

    results.push(JSON.pretty_generate(@analysis))

    # Writing temporary file
    File.open(temporary_file_path, 'w',) do |f|
      File.chmod(0777,temporary_file_path)
      FileUtils.chown 'logstash', 'logstash', temporary_file_path
      f.puts results
    end

    begin
      # Uploading file to s3
      @logger.info("Uploading #{loader} results to s3")
      open(temporary_file_path, 'r') do |f|
        @s3.put_object(bucket_name: @bucket, key: s3_result_path, data: f)
      end
    rescue => e
      @logger.error(e.message)
    end

    # Deleting temporary file
    open(temporary_file_path, 'w') do |f|
      File.delete(f)
    end
  end

  public
  def filter(event)

    @hash = event.get(@hash_field)
    @timestamp = event.get('@timestamp')
    @uuid = File.basename(event.get(@file_field))
    @analysis = event.get(@results_field)

    upload_results_file_to_s3

    # filter_matched should go in the last line of our successful code
    filter_matched(event)

  end  # def filter(event)
end # class LogStash::Filters::S3-upload-malware-results
