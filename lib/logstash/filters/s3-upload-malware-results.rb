# encoding: utf-8
require "logstash/filters/base"
require "logstash/namespace"

require 'aws-sdk-v1'
require 'json'


class LogStash::Filters::S3UploadMalwareResults < LogStash::Filters::Base


  config_name "s3-upload-malware-results"

  # Where results are going to be stored in s3.
  config :s3_path,                          :validate => :string,           :default => "/mdata/resultData/realTime/"
  # File from which is going to be taken the name.
  config :file_field,                       :validate => :string,           :default => "[path]"
  # Results that are going to be upload to s3.
  config :results_field,                    :validate => :string,           :default => ""
  # Loader name.
  config :loader,                           :validate => :string,           :required => true
  # S3 bucket
  config :bucket,                           :validate => :string,           :default => "malware"
  # S3 Endpoint
  config :endpoint,                         :validate => :string,           :default => "s3.redborder.cluster"
  # S3 Access key
  config :access_key_id,                    :validate => :string,           :required => true
  # S3 Secret Access key
  config :secret_access_key,                :validate => :string,           :required => true
  # S3 force_path_style option
  config :force_path_style,                 :validate => :boolean,          :default => true
  # S3 ssl_verify_peer option
  config :ssl_verify_peer,                  :validate => :boolean,          :default => false
  # Certificate path
  config :ssl_ca_bundle,                    :validate => :string,           :default => "/var/opt/opscode/nginx/ca/s3.redborder.cluster.crt"


  public
  def register
    # Add instance variables
    @s3 = AWS::S3::Client.new(
      endpoint: @endpoint,
      access_key_id: @access_key_id,
      secret_access_key: @secret_access_key,
      force_path_style:  @force_path_style,
      ssl_verify_peer: @ssl_verify_peer,
      ssl_ca_bundle: @ssl_ca_bundle
    )
  end # def register

  private

  def upload_results_file_to_s3

    time = Time.at(@timestamp.to_i)

    year  = time.year.to_s
    month = ('%02d' % time.month).to_s
    day   = ('%02d' % time.day).to_s
    hour  = ('%02d' % time.hour).to_s

    folder = year + "/" + month + "/" + day  + "/" + hour  + "/" + @uuid

    s3_result_path = @s3_path + folder

    temporary_file_path = '/tmp/' + @uuid

    results = []
    begin
      s3_object = @s3.get_object(bucket_name: @bucket, key: s3_result_path).data[:data]
      s3_object.gsub!('null','nil')
      results = eval(s3_object)
    rescue AWS::S3::Errors::NoSuchKey
      results = []
    rescue => e
      @logger.error(e.message)
    end

    @analysis["loader"] = @loader
    @analysis["sha256"] = "#{@hash}"

    results.map! { | result | JSON.pretty_generate(JSON.parse(result.to_json))}
    results.push(JSON.pretty_generate(@analysis))

    # Writing temporary file
    File.open(temporary_file_path, 'w',) do |f|
      File.chmod(0777,temporary_file_path)
      FileUtils.chown 'logstash', 'logstash', temporary_file_path
      f.puts '['
      results.each_with_index do |result, index|
        if index == results.size - 1
          f.puts result
        else
          f.puts(result + ',')
        end
      end
      f.puts ']'
    end

    begin
      # Uploading file to s3
      @logger.info("Uploading #{@loader} results to s3")
      open(temporary_file_path, 'r') do |f|
        @s3.put_object(bucket_name: @bucket, key: s3_result_path, data: f)
      end
    rescue => e
      @logger.error(e.message)
    end

    # Deleting temporary file
    open(temporary_file_path, 'w') do |f|
      #File.delete(f)
    end
  end

  public
  def filter(event)

    @results_field = @loader if @results_field.empty?
    @hash = event.get('sha256')
    @timestamp = event.get('@timestamp')
    @uuid = File.basename(event.get(@file_field))
    @analysis = event.get(@results_field)

    upload_results_file_to_s3

    # filter_matched should go in the last line of our successful code
    filter_matched(event)

  end  # def filter(event)
end # class LogStash::Filters::S3-upload-malware-results
